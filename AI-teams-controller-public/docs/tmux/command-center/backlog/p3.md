## P3 - Low Priority / Nice to Have

### [EPIC] Claude Code CLI for Team Operations
**Status:** TODO
**Priority:** P3 (Nice to have, not critical)
**Size:** L (Large - 4 phases)

**Problem:** Current team operation buttons work but could be improved with headless Claude Code CLI approach.

**Reference Code:** `/home/hungson175/dev/experiments/claude-code-headless-demo/`
- `QUICK_START.md` - Quick start guide
- `python_examples.py` - Python wrapper class `ClaudeHeadless`
- `bash_examples.sh` - Bash CLI examples
- `automation_example.py` - Automation demo

**Key CLI Usage:**
```bash
# Basic headless query with tool permissions
claude -p "prompt" --allowedTools Bash,Read,Edit

# With working directory
claude -p "prompt" --cwd /path/to/project

# JSON output
claude -p "prompt" --output-format json
```

**Implementation Phases:**
1. **Phase 1: Clean slate** - Delete ALL current broken buttons
2. **Phase 2: Restart Team** - Use CLI with CLAUDE.md restart prompt
3. **Phase 3: Load Team** - Use CLI to run setup-team.sh
4. **Phase 4: Create Team** - Use CLI to scaffold from template

**Acceptance Criteria:**
- [ ] All old team operation buttons removed
- [ ] Restart team works via Claude Code CLI (use existing CLAUDE.md prompt)
- [ ] Load team works via Claude Code CLI
- [ ] Create team works via Claude Code CLI
- [ ] Document CLI approach for future reference

---

### Security Hardening (Local Dev Tool)
**Status:** TODO
**Priority:** P3 (Low - this is a local dev tool, not production SaaS)

**Issues:**
- Command injection risk in tmux_service.py
- JWT secret hardcoded
- CORS wildcard (*)

**Note:** Since this is primarily a LOCAL development tool (not a multi-tenant SaaS), security is less critical. Address only if distributing to untrusted users.

---

### [EPIC] Voice-Controlled Navigation
**Status:** IDEA
**Priority:** P3

**Vision:** Enable hands-free control of the web app via voice commands with "Commander" trigger keyword.

**Examples:**
- "Commander, switch to team Alpha"
- "Commander, restart team Backend"

**Note:** Fun feature but not essential for core functionality.

---

### Headphone Hardware Button for Voice Control
**Status:** IDEA
**Priority:** P3

**Feature:** Toggle voice input with headphone play/pause button (web only, Media Session API).

**Note:** Real device testing required (Playwright cannot simulate hardware buttons).

---

## Ideas / Future (Not Yet Prioritized)

### [EPIC] Team Creator UI - Visual Team Builder
Create visual UI for building tmux teams from templates + PRD input.

---

### [EPIC] Independent QA Team
Separate QA team for black-box quality evaluation.

---

### Convert DK to On-Demand Sub-Agent
**Problem:** DK pane sits idle most of the time, consuming resources.

**Proposal:** Convert DK from dedicated pane to sub-agent PM spawns on-demand.

---

### Clarify Team Creation User Flow
**Problem:** "Create Team from Template" is not discoverable. Users confuse TeamCreatorPanel with CreateTeamDialog.

---

### Tab Autocomplete for File/Directory Paths
**Problem:** No tab autocomplete for paths in web UI terminal.

---

### Separate TeamCreatorPanel from Template Creation
**Problem:** TeamCreatorPanel uses hardcoded templates vs CreateTeamDialog uses backend API.

---

### CRITICAL: Professional Codebase Refactoring & Architecture Review
**Status:** TODO (URGENT - Boss Directive 2026-01-04)
**Size:** XL (Epic - Multi-sprint effort)
**Priority:** P0 (CRITICAL - Project evolution requires this NOW)

**Problem Statement:**
Project evolved from hobby → production-grade online IDE. Codebase grew organically without systematic refactoring. Current state:
- File browser → Full file CRUD → Edit/Save → Syntax highlighting (Mini IDE)
- Voice control → TTS feedback → Android app
- Tmux team management → Multi-agent coordination
- **Technical debt accumulating faster than we can address**

**Boss Directive (2026-01-04):**
> "This project started as just a hobby project, but now it's turning into a monster. The project has grown too big. So if we don't refactor the codebase now, don't review the codebase, we definitely won't be able to progress further."

**Critical Insight:**
With ~20 years coding experience, Boss recognizes this is the RIGHT TIME to refactor:
- ✅ We have unit tests (foundation for safe refactoring)
- ✅ Codebase still manageable (not yet unmaintainable)
- ✅ Clear architectural issues identified (TmuxController god component, etc.)
- ❌ But tests may not be sufficient - need careful validation

**If We Don't Refactor Now:**
- Future features become exponentially harder
- Bug fixes create more bugs
- Onboarding new developers impossible
- System becomes legacy code while still growing

---

## Proposed Approach: Parallel Refactoring Team

### Strategy A: Separate Refactoring Branch (RECOMMENDED)
**Create dedicated long-running refactoring branch:**

```
master (feature development continues)
  ↓
  └─→ refactor-v2 (professional architecture overhaul)
        ↓
        ├─ refactor-sprint-1: Backend architecture
        ├─ refactor-sprint-2: Frontend architecture
        ├─ refactor-sprint-3: API consolidation
        └─ ... (merge back when stable)
```

**Team Structure:**
- **Feature Team (command-center):** Continue Mini IDE Epic (Sprint 13, 14, 15)
- **Refactoring Team (NEW tmux team: "refactor-team"):** Professional codebase overhaul
- **Coordination:** Weekly sync between teams (SM facilitates)

**Advantages:**
- ✅ Feature development doesn't stop
- ✅ Refactoring gets dedicated focus
- ✅ Can test refactored code thoroughly before merge
- ✅ Can abandon refactoring if it goes wrong (branch stays separate)
- ✅ Boss can review refactored code before replacing production

**Risks:**
- ⚠️ Merge conflicts when combining branches
- ⚠️ Feature team builds on old architecture while refactor team fixes it
- Mitigation: Freeze new features after Sprint 15, merge refactor branch, then resume

---

### Strategy B: Fork into New Project (ALTERNATIVE)
**Create entirely new repository:**

```
AI-teams-controller (current - feature development)
AI-teams-controller-v2 (new - refactored codebase)
```

**Advantages:**
- ✅ Zero risk to existing system
- ✅ Can redesign architecture from scratch
- ✅ Boss can compare both versions side-by-side
- ✅ Migration can be gradual (deploy v2 alongside v1)

**Disadvantages:**
- ⚠️ Duplicated effort (features in v1 need porting to v2)
- ⚠️ Two codebases to maintain during transition
- ⚠️ More work for Boss to manage both

---

### Strategy C: Feature Freeze + Intensive Refactor (HIGH RISK)
**Stop all feature development, refactor for 2-4 weeks:**

**Advantages:**
- ✅ Single codebase, no merge conflicts
- ✅ Fastest path to clean architecture

**Disadvantages:**
- ❌ No new features for weeks (Boss loses momentum)
- ❌ High risk if refactoring fails (system broken, no fallback)
- ❌ Not recommended for production system

---

## Recommended: Strategy A (Parallel Branch)

**Phase 1: Setup Refactoring Infrastructure (Sprint 0)**
- [ ] Create `refactor-v2` branch from current master
- [ ] Set up new tmux team: "refactor-team" (roles: Architect, Refactorer, Reviewer)
- [ ] Document current architecture (baseline for comparison)
- [ ] Run full test suite on refactor branch (establish baseline)
- [ ] Define refactoring goals and success criteria

**Phase 2: Systematic Refactoring (Multiple Sprints)**

**Sprint R1: Backend Architecture Cleanup**
- [ ] Remove legacy SESSION_TOKEN auth (JWT only)
- [ ] Centralize API client (single Axios instance, interceptors)
- [ ] Consolidate route handlers (eliminate duplication)
- [ ] Database abstraction layer (prepare for PostgreSQL migration)
- [ ] All backend tests PASS after refactor

**Sprint R2: Frontend Architecture Overhaul**
- [ ] Refactor TmuxController (god component → composition)
  - Split into: TeamManager, PaneController, CommandController
  - Use React Context for global state
  - Eliminate prop drilling
- [ ] Consolidate API calls (custom hooks: useTeams, usePanes, useSendCommand)
- [ ] Component composition (atomic design principles)
- [ ] All frontend tests PASS after refactor

**Sprint R3: API & State Management**
- [ ] REST API consistency (standardize response formats)
- [ ] WebSocket architecture review (connection management, reconnection)
- [ ] State management patterns (Zustand or Jotai for complex state)
- [ ] Error handling standardization (toast notifications, retry logic)
- [ ] All integration tests PASS

**Sprint R4: Code Quality & Documentation**
- [ ] ESLint/Prettier rules enforcement
- [ ] TypeScript strict mode (eliminate `any` types)
- [ ] API documentation (OpenAPI/Swagger for backend)
- [ ] Component documentation (Storybook for UI components)
- [ ] Architecture decision records (ADRs)

**Sprint R5: Testing & Validation**
- [ ] Increase test coverage (target: 80%+)
- [ ] E2E tests (Playwright for critical flows)
- [ ] Performance benchmarks (compare refactored vs original)
- [ ] Security audit (same as P0 security epic, but on refactored code)
- [ ] Boss review: Does refactored system feel better?

**Phase 3: Merge & Deploy**
- [ ] Feature freeze on master (after Mini IDE Epic complete)
- [ ] Merge refactor-v2 → master (resolve conflicts carefully)
- [ ] Run FULL test suite on merged code
- [ ] Deploy to staging, Boss acceptance testing
- [ ] Deploy to production (Cloudflare tunnel points to new version)
- [ ] Monitor for regressions (1-2 weeks)

---

## Scope: What Needs Refactoring

### Backend (Python/FastAPI)
**Critical Issues:**
1. **No database** - Everything in memory (sessions lost on restart)
2. **Route handlers duplication** - Similar patterns repeated
3. **No request validation middleware** - Pydantic schemas inconsistent
4. **WebSocket connection management** - Ad-hoc reconnection logic
5. **Celery task organization** - TTS tasks not well structured

**Target Architecture:**
- PostgreSQL for persistent state
- SQLAlchemy ORM with migrations (Alembic)
- Service layer pattern (routes → services → data access)
- Dependency injection for testability
- Structured logging (not print statements)

### Frontend (Next.js/React)
**Critical Issues:**
1. **TmuxController god component** - 500+ lines, does everything
2. **Prop drilling** - Props passed 3-4 levels deep
3. **API calls scattered** - Fetch logic duplicated across components
4. **State management ad-hoc** - useState everywhere, no global state
5. **No error boundaries** - Errors crash entire UI

**Target Architecture:**
- Component composition (atomic design: atoms → molecules → organisms)
- Custom hooks for API calls (useTeams, usePanes, useSendCommand)
- Context API or Zustand for global state
- Error boundaries with fallback UI
- React Query for server state caching

### API Layer
**Critical Issues:**
1. **Inconsistent response formats** - Some return `{ data }`, some return direct values
2. **No versioning** - `/api/teams` can't evolve without breaking clients
3. **CORS wildcard `*`** - Security issue (allow specific origins only)
4. **No rate limiting** - Open to abuse
5. **Authentication scattered** - Some endpoints check token, some don't

**Target Architecture:**
- Versioned API (`/api/v1/teams`, `/api/v2/teams`)
- Standardized responses: `{ success, data, error, metadata }`
- Authentication middleware (all endpoints require auth)
- Rate limiting (per-user quotas)
- OpenAPI documentation (auto-generated from code)

---

## Success Criteria

**Quantitative:**
- [ ] Test coverage: ≥80% (up from current ~60%)
- [ ] Build time: ≤10 seconds (currently ~10s, maintain or improve)
- [ ] Bundle size: ≤1MB gzipped (currently ~800KB, don't bloat)
- [ ] API response time: <100ms p95 (measure before/after)
- [ ] Zero regressions (all existing features work identically)

**Qualitative:**
- [ ] Boss review: "System feels cleaner, easier to understand"
- [ ] New features: "Easier to add features after refactor than before"
- [ ] Onboarding: "New developer can understand codebase in <1 day"
- [ ] Confidence: "Boss comfortable making changes without breaking things"

---

## Boss Collaboration Required

**This is NOT a task for the team to execute autonomously.** Boss needs to:

1. **Choose Strategy:** Branch (A), Fork (B), or Freeze (C)?
2. **Define Scope:** Which areas MUST be refactored vs nice-to-have?
3. **Set Timeline:** How many weeks can we dedicate to refactoring?
4. **Review Architecture:** Boss has 20 years experience - architectural decisions need Boss input
5. **Acceptance Criteria:** What does "success" look like for Boss?

**Proposed Next Steps:**
1. **PO schedules brainstorming session with Boss** (30-60 min)
2. **Boss + PO discuss:**
   - Current pain points in codebase
   - Which strategy (A, B, or C)
   - Refactoring team composition
   - Timeline and priorities
3. **PO creates detailed refactoring epic** based on Boss decisions
4. **SM sets up refactor-team tmux session** (if Strategy A)
5. **Team begins systematic refactoring** while feature team continues Mini IDE

---

## Why P0 (Critical Priority)

**Not P1 or P2** - this MUST happen before more features:

1. **Technical Debt Compound Interest:**
   - Every new feature built on shaky foundation adds more debt
   - Refactoring becomes HARDER the longer we wait
   - "Move fast and break things" worked for hobby project, not anymore

2. **Feature Velocity Declining:**
   - Sprint 12: 8 min implementation (simple CRUD endpoint)
   - Future sprints: Will take exponentially longer due to complexity
   - Refactoring NOW maintains velocity for future

3. **Boss Time Investment:**
   - Boss can't scale if codebase is unmaintainable
   - Clean architecture → Boss can delegate to team confidently
   - Messy architecture → Boss must review every change (bottleneck)

4. **Project Viability:**
   - Hobby project → Production IDE transition is CRITICAL MOMENT
   - Either refactor now and succeed, or accumulate debt and fail
   - No middle ground at this inflection point

---

## Estimated Effort

**Conservative Estimate:**
- **Sprint R0 (Setup):** 1 week
- **Sprint R1-R4 (Refactoring):** 4-6 weeks (1-1.5 weeks per sprint)
- **Sprint R5 (Testing):** 1-2 weeks
- **Merge & Deploy:** 1 week
- **Total: 8-10 weeks** for comprehensive refactoring

**Aggressive Estimate:**
- Focus on critical issues only (Backend + Frontend architecture)
- **Total: 4-6 weeks**

**Parallel Development:**
- Feature team completes Mini IDE Epic (Sprint 13-15) in 2-3 weeks
- Refactoring team works in parallel
- Both complete around same time → merge → deploy v2

---

## Alternative: CodeRabbit AI Code Review Integration

**If Boss prefers AI-assisted refactoring:**
- Tool: CodeRabbit (mentioned in backlog at line 1215)
- Cost: $48/month
- Benefit: Automated code review, refactoring suggestions
- Limitation: AI can't make architectural decisions (Boss still needed)

**Recommendation:** Use CodeRabbit AFTER manual refactoring for ongoing quality

---

## Dependencies

**Blockers:**
- None - can start immediately after Boss brainstorming session

**Enables:**
- PostgreSQL migration (Sprint 25 - blocked on clean architecture)
- Team collaboration features (blocked on state management refactor)
- Mobile app improvements (blocked on API versioning)
- Third-party integrations (blocked on API standardization)

---

**Created By:** PO (Product Owner)
**Date:** 2026-01-04
**Status:** DRAFT - Awaiting Boss brainstorming session and strategy decision
**Priority:** P0 (CRITICAL - Must happen before more features)

---

### "Failed to fetch" Error Handling
- Graceful error when backend unreachable

---

### CodeRabbit AI Code Review
- Cost: $48/month
- Automated code reviews

---
